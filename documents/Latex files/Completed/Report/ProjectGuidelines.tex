\documentclass[12pt,a4paper]{article}
\usepackage{graphicx}
\usepackage{biblatex}
\usepackage{parskip}
\usepackage{listings}
\usepackage{pdfpages}
\usepackage{rotating}
\usepackage{pdflscape}
\usepackage{amsmath}
\usepackage{subcaption} 

\lstset{%
basicstyle=\ttfamily,
breaklines = true,
tabsize=2
}
\graphicspath{ {./Images/} }
\addbibresource{biblography.bib}

\setlength{\parskip}{1em}
\begin{document}

\begin{titlepage}
	\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
    \includegraphics[width = 4cm]{./Images/Logo.jpg}\\[0.5cm] 
    
    \center 
	\textsc{\large Department of Electrical and Electronic Engineering }\\[0.5cm] 
	\textsc{\normalsize ELEC40006: Electronics Design Project}\\[0.5cm] 
    
	\HRule \\[0.4cm]
	Circuit Simulator Technical Report
    \HRule \\[1.5cm]
     
    \begin{center}
		\underline{Authors}\\[0.5cm] Xin Wang\\CID: 01735253\\xin.wang19@imperial.ac.uk \\[0.5cm]
		Brandon Cann\\ CID: 01724765\\ brandon.cann19@imperial.ac.uk\\[0.5cm]
		Adam Rehman\\ CID: 01720256\\adam.rehman19@imperial.ac.uk\\[0.5cm]
	\end{center} \large
    
    \vfill % Fill the rest of the page with whitespace
 	\small Word Count: 4438 \\ [0.5cm]
    \makeatletter
    \@date 
    \makeatother
\end{titlepage}

\tableofcontents
\pagebreak

\section{Overview of the report}
Report layout loosely follows the stages of the Software Developement Cycle. \par
Section 2 detailed the design problem presented and the program requirements at are necessary for a preliminary design 
to be established. \par
Section 3 provideed a summary of the program development timeline and the details related to project management,
format of meeting minutes used to how the responsibilities are distributed among the project team. \par
Section 4 discussed the preliminary designs the team had produced and the rationale behind some design choices the team had 
implemented. \par
Section 5 gave a comprehensive overview of the program design, the functions and flowcharts used during program 
developement. \par 
Section 6 investigated the design constraints of the program, the accuracy of the results had produced and the speed of 
execution as the circuit size varied.\par
Section 7 discussed the major unforeseen problems encountered by the team over the course of the project and 
how the team attempted to mitigate that problem. \par
Section 8 discussed the possible improvements noted by the team that could mitigate concerns encountered
by the team. \par
Section 9 detailed the possible features that can be added on to the existing program and the required modifications to the
program to add the mentioned features. \par 
Section 10 contained the reflections written by each teammate towards the end of the project. \par
\pagebreak

\section{Project Specification}
	\subsection{Design Problem}
	Develop a program that is able to read in a file describing a circuit specified by the user, perform 
	transient simulation on that circuit and output the calculated voltages at each instance in time into a specific file
	format. 
	\subsection{Program Requirements}
	The main program requirements are listed as follows:
	\begin{itemize}
		\item Program must support basic circuit components listed as follows \footnote{Advanced component can be supported
		provided basic components are already implemented.}:
		\begin{itemize}
			\item Resistors
			\item Ideal Capacitors
			\item Ideal Inductors
		\end{itemize}
		\item Parser to be designed to take in a input file of SPICE netlist format.
		\begin{itemize}
			\item Basic syntax checks to be performed.
		\end{itemize}
		\item The output file must be in Comma Separated Value (.CSV) format.
		\begin{itemize}
			\item Columns of output file represent nodes in the circuit.
			\item Rows of output file represent an instance in the simulation.
		\end{itemize}
	\end{itemize}
	\vfill
	\pagebreak
	\subsection{Design Criteria}
	The team had identified several factors from the list given in the Product Design Specification \footnote{}
	document.
	\begin{itemize}
		\item Maintenance: One of the most important factors the team identified. As the development timescale is 
		constrained and the features required is open-ended, so it is important we ensure the design can 
		incorporate new features efficiently and cost-effectively if the client wishes to add new features.
		\item Documentation: For a non-intuitive program, proper documentation is required for client and future
		programmers to make modifications should the client wish.
		\item Performance: No strict performance guidelines are given by the client but the execution 
		speed should still be reasonable. 
		\item Time scale: 6 weeks with a definite deadline. It is important to balance proper team management
		techniques and creating a program that meets client standards.
		\item Testing: Numerous test programs have been created to test various aspects of the program to ensure
		accurate results have been produced. The results produced have been verified with LTSpice, a well 
		established circuit simulation program.
		\item Patents: SPICE engine is a public domain software so we could possibily utilise the engine.
		\item Ergonomics: A Graphics User Interface (GUI) is not specified by the client and could possibly 
		make the program much easier to use.
	\end{itemize}
	\vfill
	\pagebreak

\section{Team Management}
	\subsection{Project timeline overview}
	\includegraphics{Timeline.PNG}
	\pagebreak

	\subsection{Team Gnatt chart}
	The team Gnatt Chart is created by using the GnattProject software. It was not the most 
	visually appealing software but, for its free features, it met the requirements of the team. \par
	The Gnatt Project was mainly modified by Xin Wang upon requests by teammates or after meetings. Please
	refer to the Appendix: Gnatt Chart for detailed break down of the team's Gnatt Chart. \par
	\subsubsection{Important Notes:}
	\begin{itemize}
		\item Activities like ensuring standardised coding comments and formatting which was monitored by 
		Xin Wang was a constant ongoing activity in the background. 
		\item A team meeting ocurred after each stage of the Gnatt Chart was finished (Indicated by 
		a change in colour).
		\item On the 5th June of 2020, Xin Wang received a notification for a repatriation flight
		and, in the following team meeting, the team agreed on redistributing Xin Wang's responsibilities
		and for him to finish the existing Technical Report.
	\end{itemize}
	

	\pagebreak

	\subsection{Management approach}
	The project team, with research on different forms of project management, decided on using a Waterfall project
	management approach. The phases are listed as follows: \par
	\begin{itemize}
		\item System and Software Requirements.
		\item Analysis.
		\item Design.
		\item Coding.
		\item Testing.
	\end{itemize}
	This method is selected mainly since the project is short, requirements are clear and the team 
	is not constantly required to report to the client at the early stages of the software development to ensure 
	client statisfaction. \par

	The Waterfall methodology prioritises proper documentation throughout the whole development process. This is important
	to the team as the team project requires a Project Report to be submitted and, due to the ongoing remote lab orals and 
	family-related obligations during quarantine, allows a team member to be quickly caught up should a member step out
	of the team for a while.  

	The disadvantage of the Waterfall methodology lies mainly in that no working software is produced until late in the 
	cycle so there is a level of risk and uncertainty with not being able to meet the deadline, especially in the 
	current state of the world \footnote{Any unforseen circumstances are listed in team meeting minutes summarised the following sections.}. 
	The project team later realised the methodology is not exactly suitable for the Object Orientated Approach 
	that the team eventually settled on. As the integration is done at the end, there is a possibility that any errors
	in the program is not caught during integration.

	\vfill
	\pagebreak

	\subsection{Team responsibilities breakdown}
	The responsibilities of each team member is discussed during the 1st meeting and formalised in the 2nd meeting. The
	respective roles are partly determined by the Belbin questionnaire provided by Mrs. Perea 
	\footnote{Belbin questionnaire forms are found in Appendix: Belbin Roles.}
	\par
	The main responsibilities of each team member is listed as follows:
	\begin{itemize}
		\item Adam Rehman
		\begin{itemize}
			\item Plant
			\begin{itemize}
				\item Research program.
				\item Coding the program.
				\item Testing program.
			\end{itemize}
		\end{itemize}
		\item Brandon Cann
		\begin{itemize}
			\item Monitor Evaluator
			\begin{itemize}
				\item Ensure documentation managed by Xin Wang and coding managed by Adam is in sync.
				\item Contributes to program aspects that are falling behind.
				\item Ensure project requirements are met.
			\end{itemize}
		\end{itemize}
		\item Xin Wang
		\begin{itemize}
			\item Implementer
			\begin{itemize}
				\item Creating and managing the team Project Report and various other documentations.
				\item Meeting minute keeper.
				\item Ensuring code written is up to a standard format with proper comments.
				\item Manages repository base.
			\end{itemize}
		\end{itemize}
	\end{itemize}

	\vfill
	\pagebreak

	\subsection{Project meeting minutes}
	The meeting minutes follow a standard template that is attached under Appendix: Meeting Minutes. \par
	There is no standard protocol for calling team meetings, they are called usually when there is a problem
	that is applicable to all team members. Usually, there is informal communication across various channels from 
	WhatsApp to Discord. \par
	Over the course of the development cycle, there has been three formal meetings and the main reasons and conclusions
	are listed below.
	\begin{itemize}
		\item Meeting 1
		\begin{itemize}
			\item Reason: 
			\begin{itemize}
				\item Project team meeting each other. Not every team member knows each other.
				\item Discuss the Circuit Simulator briefing.
			\end{itemize}
			\item Conclusions:
			\begin{itemize}
				\item Xin Wang was assigned as documentation manager and tasked with formalising the Project Requirement.
			\end{itemize}
		\end{itemize}
		\item Meeting 2
		\begin{itemize}
			\item Reason:
			\begin{itemize}
				\item With a draft of the project management guidelines, team discussed the team dynamics.
				\item Discussed general direction of our program design.
			\end{itemize}
			\item Conclusion:
			\begin{itemize}
				\item Agreed that practicing proper team management is just as important as showing practical skills 
				in coding.
				\item Final team management guidelines are agreed and tasked to Xin Wang to formalise in documentation.
			\end{itemize}
		\end{itemize}
		\item Meeting 3
		\begin{itemize}
			\item Reason:
			\begin{itemize}
				\item Program basic requirements are nearly fulfilled. 
				\item Meeting to discuss future program design direction.
				\item Xin Wang has a notification by South African Embassy of a Repartiation flight.
			\end{itemize}
			\item Conclusion:
			\begin{itemize}
				\item Plans set to divide up Xin's responsibilities among the other two team members.
				\item Documentation finalised and notes written by Xin passed to team members.
			\end{itemize}
		\end{itemize}
	\end{itemize}
	\pagebreak

	

\section{Preliminary Designs}
Our initial program design relied on the project briefing provided by Dr Stott. Parsing a input file into a data 
structure is a standard procedure. The main point of discussion is related to how the program solves for unknown voltages.
\par
The main design choices taken by the team has been set out below.
	\subsection{Object Orientated Programming}
	As the number of circuit components that we need to support is open ended besides the mandatory basic components 
	according to the Project Breifing, the team was concerned on the expandability of the program.
	\par
	The OOP approach allows the program design to be rapidly and cost-effectively altered to accomodate new features
	such as additional circuit components or analysis techniques \cite{OOP} that the client might request later on in the 
	program's lifecycle. This approach saves the programmer and the client cost and time in program maintainability.
	\par
	The disadvantage to that approach is that it has shown to be slower than other preliminary programs designed 
	without OOP to an average of of 5\% to 10\% slower depending on other optimisations in the program.
	\par 
	It is the team's view that execution speed was not the highest priority and the ability to expand was also 
	important. The design is detailed in the next section.

	\subsection{Modified Nodal Analysis}
	Modified Nodal Analysis (MNA) is an extension of normal Nodal Analysis. When the team start researching similar 
	programs like PSPICE and LTSpice, MNA was mentioned numerous times \cite{MNA} and its benefits was clearly seen when we tried 
	to write a program that implemented normal Nodal Analysis. A problem the team encountered was trying to 
	represent the current-dependent circuit elements like inductors efficiently. 
	\par
	As stated earlier, a primary concern of the team lies in the scalability of the program. By using MNA, just like
	other commercial programs, the team is confident that the analysis component of the program will not be a 
	bottleneck to future developments of the program.
	\par
	THe advantage of MNA is in its standard procedures. The standardised algorithm for solving nodal 
	equations allowed the team to modularise the solving aspect of the program. This meant not constantly have to 
	make changes to one of the most important parts of the program, instead just ensuring the component is in the 
	compatible format to be entered into the MNA algorithm.
	\par 
	The MNA algorithm consists of three matrices to form the matrix relation: $Ax=b$ \cite{MNA}:
	\begin{itemize}
		\item $A$ is consists of four submatrices which includes the admittance matrix. The program treats matrix $A$ as 
		a whole matrix instead of separating it into four small matrices and combining at the end.
		$$ A =
		\begin{bmatrix}
			G & B\\
			C & D 
		\end{bmatrix} $$

		\item $x$ represents the unknown node voltages and current of the voltage sources.
		$$ x =
		\begin{bmatrix}
			v \\
			i_{v} 
		\end{bmatrix} $$

		\item $b$ contains the values of voltage sources and current sources in the circuit.
		$$ b =
		\begin{bmatrix}
			i \\
			e 
		\end{bmatrix} $$

	\end{itemize}
	The admittance matrix is created during the initialisation of the simulation. Non-linear elements are converted into 
	suitable formats at each instance in time during a transient simulation. The resulting parameters are 'stamped' into the matrix
	at each instance. Only 'stamping' the changing values instead of creating a new system of matrices saves valuable execution time
	during program execution. The matrix inversion is handled by the Eigen library, the library supports various types of 
	inversion with difference accuracy and speed and this is discussed in the Optimisation sector.

	\subsection{Eigen Matrix Library}
	In terms of matrix operations, the team decided to use a third-party program to handle the matrix-related operations.
	The primary concern with choosing a third-party program was how seamless the program integrates into our program. 
	The team does not know whether the client would be comfortable installing an unknown third-party program on their system 
	besides the program that the client specifically requested for.\par
	There are third-party programs that require installation such as Armadillo and some has a large file size such as the 
	Boost Library which is close to 1GB.
	Based on the concerns laid out, the team looked for a program that has a reasonable size, does not require installation 
	in order to be used. The third-party program chosen was Eigen. It is a file that has a reasonable size and only requires that the
	Eigen is located in the same directory and the execution scripts we provided is used. A copy of Eigen is included in the program
	files so client's ease of usage.
	\pagebreak

\section{Program Design}
	\subsection{Top level view of the program}
	\begin{figure} [h!]
		\centering
		\includegraphics[scale=0.5]{Flow chart.PNG}
		\caption{General flowchart of program}
	\end{figure}
	\textit{circuit.hpp} file forms the central section of the program, handling the input of the file and 
	storing it in a form that allows the \textit{simulate} file to perform Transient Analysis on it and outputs
	the file in the format (.CSV) specified by the client.
	\par
	The theoretical information and program design for each of the main files are discussed in the following 
	sections.
	\pagebreak
	\subsection{Components files}
	Due to the OOP design methodology, each component and its necessary functions are described in its own
	respective file. The file \textit{edge.hpp} is the base from which all other circuit components are derived
	from the \textbf{components} folder. 
	\subsection{\textit{str handler.hpp} file}
	The \textit{str handler} file manages all string-related functions. \par
	The main function is the is the \textit{tokenisier} function which takes in an 
	input sentence and separates it into individual words that can be processed, 
	converted into the required formats for processing and stored. \par
	During conversions, checks are performed at various stages. In the product briefing, there
	was no mention of error handling requirements but the team viewed that defensive programming 
	was required and any errors encountered will be displayed to the user. 

	\subsection{\textit{node.hpp} file}
	A circuit can be expressed as a Network Graph, containing branches and edges.
	The \textit{node.hpp} file expresses a node in the circuit and allows nodal equations
	to be created.\par
	This function is not necessary in the final design since the program skips creating nodal
	equations and directly inputs entries into the matrix before solving it.
	\pagebreak
	\subsection{\textit{circuit.hpp}}
	As mentioned previously, \textit{circuit.hpp} manages all aspects of the program from 
	reading in the user input, checking basic syntax errors during user entry 
	to ensuring the simulation is successful.
	Numerous checks are performed over the course of the simulation and any errors encountered
	will instantly result in the simulation ending. \par
	
	The flow chart of \textit{circuit.hpp} is shown as below: \par
	\begin{figure} [h!]
		\centering
		\includegraphics[scale=0.5]{circuit.PNG}
		\caption{Circuit flow chart}
	\end{figure}
	\pagebreak
	\subsection{\textit{simulate.hpp}}
	This section of the program was where the team has spent most of the time and also where the
	team saw many possible optimisations which will be discussed in later sections. This 
	section handles matrix entry and controls the transient simulation. \par
	But using the MNA technique, basic components such as voltage sources, current 
	sources and resistors are simple and can be directly entered into the matrices for 
	solving. However, components such as inductors and capacitors which are non-linear
	devices has required further processing in order to support those components. 
	At each instance in time, non-linear components need to be approximated into corresponding
	companion models. With the program using MNA, all non-linear components are converted 
	into a current source and resistor to allow efficient entry into the matrix.
	\subsubsection{Non-linear components}
	In the process of approximating non-linear components, integration is 
	required and there are three different 
	methods of integration each with its own corresponding equations defining 
	current and resistance of the companion model. Each type of integration offers different
	degree of accuracy which is explored under the Optimisation section.\par
	Capacitors are defined with the following differential equation:
	$$I=C\times \frac{dv}{dt}$$
	Inductors are defined with the following differential equation:
	$$V=L\times \frac{di}{dt}$$
	
	\begin{figure} 
		\centering
		\includegraphics[scale=0.90]{capacitor.PNG}
		\caption{\centering Capacitor companion model parameters for different types of integration 
		\cite{companion}}
	\end{figure} 
	\begin{figure} 
		\centering
		\includegraphics[scale=0.90]{inductor.PNG}
		\caption{\centering Inductor companion model parameters for different types of integration 
		\cite{companion}}
	\end{figure}
	\pagebreak
	\subsubsection{Simulation flowchart} 
	The listed simulation flowchart has not accounted for approximating components like Diodes which need Newton-Raphson 
	iteration.
	\begin{figure} [h!]
		\centering
		\includegraphics[scale=0.5]{simulate.PNG} 
	\end{figure} 
\pagebreak

\section{Testing}
It should be noted that majority of the testing is done on Linux Ubuntu 16.04.1 LTS which runs on a virtual machine in Windows 10,
some testing have been completed on a Windows 10 machine. As such, the listed execution times are the average of 10 execution
times. \par 
Numerous functions are imbedded into the program itself to aide the benchmarking process and can be used to aide in debugging.
\pagebreak
\section{Critical Analysis}
Throughout the process of program development, the team encountered two unforeseen circumstances that set the team back 
and required some adjustments on the timeline.
\subsection{OOP design}
It was felt strongly by the team that OOP design was required by the program. However, how the modules of the program were 
arranged was a topic that was argued and constantly revised. \par 
To this problem, the team researched articles that investigated how circuit simulators could be implemented from the 
OOP perspective and, also, the team drew inspirations from the technical documentations of more established circuit 
simulation programs like SPICE3 and PSpice.
\subsection{Repatriation Flight}
On the 4th of June 2020, Xin Wang received a notification of a possible repatriation flight for South African citizens.
As the exact time of the flight is not known yet and there was no guarantee that the quarantine site would have WIFI, it
was very likely that Xin Wang could not be reached once arriving at South Africa. There was many unknown variables and the 
responsibilities that Xin Wang handled was very critical in this final stage of the program. \par 

In the final team meeting, the team was briefed by Xin Wang of the state of the reports and what was still outstanding. 
As it was the weekend, the team could not reach the professors in charge of the project so the team had to make the 
decisions and mitigate the possible effects of Xin's absence. The meeting conclusions are summarised as below:
\begin{itemize}
	\item Xin Wang to complete what can be completed on the report (Some data such as Testing has been completed yet)
	\item Xin Wang, once report is completed, shall handover the responsibilities to the remaining two teammates.
	\item Xin Wang will document any ideas he has yet to implement such as a guide to the demo video talking points.
	\item Tasks that the two teammates still have to complete:
	\begin{itemize}
		\item Advanced component support
		\item Demo video
		\item Testing results and report  
	\end{itemize}
\end{itemize}
The team understood that in the workplace, there would be unforeseen circumstances that affected the team's workflow.
It is important that the client's basic requirements are still met albeit some of the more advanced features would not be 
able to be completed but will still be documented under section: Adding On for the client to see and consider implementing.
\par 
Xin Wang will constantly keep the team brief on whether he can lend any help in preparing the program for submission. However
in order to minimise unknown variables, the team planned with the possibility of Xin Wang not being able to communicate and the
remaining team will have to handle report submission and video demonstration.
\pagebreak
\section{Optimisations}
\subsection{Sparse Matrices}
Various circuit simulation engines like SPICE uses sparse matrices and it was mentioned \cite{OOP} during our research stage but 
the current program used dense matrices. The primary concern was stability of the program as the team did not have 
any experience with Sparse Matrices but the Eigen Library is able to implement sparse matrices. \par
With the current supported circuit components, using dense matrices does not affect the program speed significantly. But as 
the circuit size gets bigger and more complicated components like operational amplifiers is supported, the matrices would
get bigger. The memory used and the processing power used would increase proportionally. \par
Sparse matrices solves that problem as numerous entries of the matrices is zero and does not affect the results. The benefit is
reduced memory usage and much faster program execution times which is a bottleneck in the current design.
Due to the OOP program design, it can be quickly implemented but extensive testing would be needed.
\subsection{Integration method}
There are numerous different types of integration but the three most common forms of integration are as follows:
\begin{itemize}
	\item Forward Euler
	\item Backward Euler
	\item Trapezoid
\end{itemize}
Out of the three, Trapezoid is the most accurate form of integration but the most processor intensive form of integration listed.
The report has listed the three forms of integration and its respectively defined parameters. 

\begin{figure} [h!]
	\centering
	\includegraphics[]{Integration.PNG}
	\caption{Accuracy comparison of different integration methods \cite{integration}}
\end{figure}
\par
But Euler's methods are only accurate to the first degree while other methods such as the Runge-Kutta method is much more accurate.
This method would rely on creating a specialised function that exclusively handles it and would add to the processing time but,
with the implementation of sparse matrices, the team believes it would still result in a faster program.

\subsection{Inversion method}
The Eigen library supports numerous types of equation solver functions. The default type that the Eigen documentation supports is the 
\textit{ColPivHouseholderQR} method but, using it, resulted in a consistent execution time of 50\% longer. Instead, the team 
did not use the equation solver functions. The team used the inversion function on matrix $A$ and multiplied it directly to matrix $b$.
\par 
The team believes that there is be more efficient third-party algorithms that can help make the program more efficient. For example, 
the Boost Library contains numerous functions that can entirely eliminate the need for the \textit{str handler.hpp} file and,
as it is a extensively supported library, it would be more efficient to use it. But it would require client consultations to ensure
the client understands and is comfortable with a larger program size. 

\pagebreak

\section{Adding on}
\subsection{Graphics User Interface}
The current user interface is very limited, it consists of only a basic interface created
in with bash script. The output file, though in .CSV format, required the user to 
use third-party programs like MatLab to plot the graph. If the user used the third-party
program, GNUPLOT, it is possible to integrate graph plotting feature directly into the existing 
script. 
\par 
Alternatively, a more user intuitive interface can be created in the future. Given the 
limited programming capability of the team, a third-party program to support the 
development of the User Interface was thought best by the team. Through research, the 
team has identified several possible programs that can be used:
\begin{itemize}
	\item \textit{Qt}
	\item \textit{wxWidgets}
	\item \textit{gtkmm}
\end{itemize}
The team's primary research was centered on the \textit{Qt} program. \textit{Qt} is a open
source program and it is relatively easy given its complete feature set, using that program
would minimise development cost and the interface features would not be limited.

Furthermore, with the C++ programming language used to create the program and the compatibility
of \textit{Qt} with C++, the team feels confident Qt would be the program used by the team
to implemented the Graphical User Interface.

\subsection{Components supports}
\subsubsection{Diode}
For non-linear components like the Diode, a function would need to be created that will be able to 
approximate the component into a compatible model for our program. The diode is defined by the 
following relation $$i(v)=I_s(e^{(\frac{v}{V_t})}-1)$$

By using the Newton-Raphson method, the non-linear equation is linearised to the following equation\cite{companion}
$$i_{lin} = (i(v_n)-gv_n) + gv$$
The equation can then be used to derive the following companion model:

\begin{figure} [h!]
	\centering
	\includegraphics[]{diode_model.PNG}
	\caption{Companion model of the diode and its defining parameters \cite{companion}}
\end{figure}
As the Newton-Raphson iteration method requires the calculations to converge to a solution, in the event that it does not
converge and max repetitions have been reached, the program could implement a Convergence Helper such as \textit{gMin stepping} or
\textit{source stepping} and, it there is no more convergence helpers left then the program will output an error to the user.
The process of Newton-Raphson has many 
possible optimisations to improve the convergence such as improving the model used and the algorithm of the existing model. \par
\par 
The basic convergence parameters that would govern whether convergence has been met will be defined as:
\begin{itemize}
	\item RELTOL: Tolerance of voltages and currents.
	\item VNTOL: Tolerance of nodal voltages.
	\item ABSTOL: Tolerance of branch current.
	\item ITL: Max number of iterations allowed.
\end{itemize} 
The existing program flow chart would have to be modified to accommodate the Newton-Raphson iteration method. 
\begin{figure}
	\centering
	\includegraphics[scale=0.5]{Newton_Raphson.png}
	\caption{Program Flowchart incorporating Newton-Raphson method}
\end{figure}

\pagebreak
\subsubsection{Voltage controlled voltage sources - VCVS}
VCVS are defined in the netlist in the following format: \par 
\begin{figure} [h!]
	\centering
	\includegraphics[]{E.png}
	\caption{Netlist format describing a VCVS \cite{MNA}}
\end{figure}
The output voltage of a VCVS is defined by the following equation: $$V_{out}=Value \times (V_{NC+}-V_{NC-})$$
where $V_{NC+}$ and $V_{NC-}$ are the controlling nodes. Due to the MNA method used by the program, supporting VCVS is 
easily done by modifying the existing system of matrices and solving for unknowns.

\begin{figure} [h!]
	\centering
	\begin{subfigure}{.5\textwidth}
	  \centering
	  \includegraphics[scale=0.8]{E_diagram.PNG}
	  \caption{Circuit symbol of a VCVS}
	  \label{fig:sub1}
	\end{subfigure}%
	\begin{subfigure}{.5\textwidth}
	  \centering
	  \includegraphics[width= \textwidth]{E_matrices.PNG}
	  \caption{MNA matrix entry}
	  \label{fig:sub2}
	\end{subfigure}
	\caption{MNA matrix for a VCVS \cite{jahn_margraf_habchi_jacob_2003}}
	\label{fig:test}
\end{figure}

\subsubsection{Voltage controlled current sources - VCCS}
VCCS are defined in the netlist in the following format: \par 
\begin{figure} [h!]
	\centering
	\includegraphics[]{G.png}
	\caption{Netlist format describing a VCCS \cite{MNA}}
\end{figure}
VCCS output is considered as a current source hence only introduce one more unknown into the MNA matrix. 
It could be defined as the following:
\begin{figure} [h!]
	\centering
	\begin{subfigure}{.5\textwidth}
	  \centering
	  \includegraphics[scale=0.8]{G_diagram.PNG}
	  \caption{Circuit symbol of a VCCS}
	  \label{fig:sub1}
	\end{subfigure}%
	\begin{subfigure}{.5\textwidth}
	  \centering
	  \includegraphics[width= \textwidth]{G_matrices.PNG}
	  \caption{MNA matrix entry}
	  \label{fig:sub2}
	\end{subfigure}
	\caption{MNA matrix for a VCCS \cite{jahn_margraf_habchi_jacob_2003}}
	\label{fig:test}
\end{figure} \pagebreak

\subsubsection{Current controlled voltage sources - CCVS}
CCVS are defined in the netlist in the following format: \par
\begin{figure} [h!]
	\centering
	\includegraphics[]{H.png}
	\caption{Netlist format describing a CCVS \cite{MNA}}
\end{figure}

The controlling variable is current through one of the voltage sources listed as the controlling element in the netlist.
As MNA also calculates the current through the voltage sources, it will be relatively simple to extract that current
value and find the output of the CCVS. CCVS creates two more unknown variables.
It could be defined as the following:
\begin{figure} [h!]
	\centering
	\begin{subfigure}{.5\textwidth}
	  \centering
	  \includegraphics[scale=0.8]{H_diagram.PNG}
	  \caption{Circuit symbol of a CCVS}
	  \label{fig:sub1}
	\end{subfigure}%
	\begin{subfigure}{.5\textwidth}
	  \centering
	  \includegraphics[width= \textwidth]{H_matrices.PNG}
	  \caption{MNA matrix entry}
	  \label{fig:sub2}
	\end{subfigure}
	\caption{MNA matrix for a CCVS \cite{jahn_margraf_habchi_jacob_2003}}
	\label{fig:test}
\end{figure}
\pagebreak
\subsubsection{Current controlled current sources - CCCS}
CCCS are defined in the netlist in the following format: \par
\begin{figure} [h!]
	\centering
	\includegraphics[]{F.png}
	\caption{Netlist format describing a CCCS \cite{MNA}}
\end{figure} 
Like the CCVS, this component is controlled by the current through the listed voltage source. It is handled similarly like the CCVS.
CCCS creates one more unknown variable.
\begin{figure} [h!]
	\centering
	\begin{subfigure}{.5\textwidth}
	  \centering
	  \includegraphics[scale=0.8]{F_diagram.PNG}
	  \caption{Circuit symbol of a CCCS}
	  \label{fig:sub1}
	\end{subfigure}%
	\begin{subfigure}{.5\textwidth}
	  \centering
	  \includegraphics[width= \textwidth]{F_matrices.PNG}
	  \caption{MNA matrix entry}
	  \label{fig:sub2}
	\end{subfigure}
	\caption{MNA matrix for a CCCS \cite{jahn_margraf_habchi_jacob_2003}}
	\label{fig:test}
\end{figure}


\pagebreak
\section{Reflections}
\subsection{Xin Wang}
The project has made me realise that engineering is not only about the practical aspects that many see engineering as.
Engineering requires as much work, if not more, in planning and documentation than actually implementing the ideas. 
\par
Through serving as the person in charge of documentation and project management, I have gained an appreciation for the 
work that goes on the background and the role has challenged me to gain new skills such as learning how to write 
Latex documents and researching how a project team can be efficiently managed. 
\par 
I was initially worried that I would not be able to understand the program designs and be relegated to just being a 
minute keeper but, actually, my role required me researching the theory required to implement the program designs and it made
realise that each role in the team is equally as important and it is important that the team communication effectively and 
be able to work together. As it is our first time handling a project like this, time was wasted with trail and error to work
out a suitable team dynamic and, with COVID-19, we had to manage this is a remote working environment. It was frustrating but
the skills gained are unquestionable.
\par 
Due to the aforementioned repatriation flight, the project had an element of family obligations in it which made it all the 
more realistic for me. The workplace is not just about working and sometimes family emergencies require you to balance the 
two sides of your life. It is my view that, though the program might not have been realised to its full potential, the 
teamwork and management lessons I learnt made it all worth it and it has inspired me to read more about project management to 
allow me to contribute more the next time I work in a team. 

\subsection{Brandon Cann}


\subsection{Adam Rehman}

\pagebreak
\section{Appendix}
\subsection{Belbin Roles}
\begin{figure} [h!]
	\centering
	\includegraphics[scale=0.5]{Adam.PNG}
	\caption{Belbin Roles of Adam Rehman}
\end{figure}
\begin{figure} [h!]
	\centering
	\includegraphics[scale=0.5]{Brandon.PNG}
	\caption{Belbin Roles of Brandon Cann}
\end{figure}
\begin{figure} [h!]
	\centering
	\includegraphics[scale=0.75]{Xin.PNG}
	\caption{Belbin Roles of Xin Wang}
\end{figure}
\pagebreak

\begin{landscape}
	\subsection{Gnatt Chart}
	\begin{center}
		\begin{figure}[htb]
		\includegraphics[width=\linewidth]{Project Gnatt.PNG}
		\caption{Gnatt Chart of Team Project}
		\label{fig:landscape}
		\end{figure}
	\end{center}
\end{landscape}
\pagebreak

\section{References}
\printbibliography
\end{document}